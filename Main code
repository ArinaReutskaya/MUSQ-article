import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Wczytanie danych
from io import StringIO

data = """
Data;MGRN;REIT
2024-10-31;916.22;171.52
2024-11-30;921.32;189.58
2024-12-31;864.86;177.1
2025-01-31;880.06;179.83
2025-02-28;892.19;183.86
2025-03-31;860.74;178.14
"""

df = pd.read_csv(StringIO(data), sep=";", parse_dates=["Data"])

# Obliczanie miesięcznych stóp zwrotu
df["MGRN_ret"] = df["MGRN"].pct_change()
df["REIT_ret"] = df["REIT"].pct_change()

# Indeks czasowy
df.set_index("Data", inplace=True)

# Indeksowane stopy zwrotu
df["MGRN_index"] = (1 + df["MGRN_ret"].fillna(0)).cumprod() * 100
df["REIT_index"] = (1 + df["REIT_ret"].fillna(0)).cumprod() * 100

# Parametry
rf_annual = 0.053
monthly_rf = (1 + rf)**(1/12) - 1

# CAGR
start = df["MGRN"].iloc[0]
end = df["MGRN"].iloc[-1]
n_months = len(df) - 1
cagr = (end / start) ** (12 / n_months) - 1

# Średnie zwroty i zmienność
avg_monthly_return = df["MGRN_ret"].mean()
monthly_std = df["MGRN_ret"].std()
annualized_volatility = monthly_std * np.sqrt(12)

# Sharpe Ratio
sharpe = (avg_monthly_return - rf_monthly) / monthly_std
annualized_sharpe = sharpe * np.sqrt(12)

# Active Return
active_return = df["MGRN_ret"].mean() - df["REIT_ret"].mean()

# Tracking Error
tracking_error = (df["MGRN_ret"] - df["REIT_ret"]).std()

# Information Ratio
information_ratio = active_return / tracking_error

# Sortino Ratio
negative_returns = df["MGRN_ret"][df["MGRN_ret"] < rf_monthly]
downside_std = negative_returns.std()
sortino_ratio = (avg_monthly_return - rf_monthly) / downside_std if downside_std > 0 else np.nan

# Max Drawdown
cumulative = (1 + df["MGRN_ret"].fillna(0)).cumprod()
rolling_max = cumulative.cummax()
drawdown = (cumulative - rolling_max) / rolling_max
max_drawdown = drawdown.min()

print("\n")
print("\n")


# Przygotowanie tabel
basic_stats = {
    "CAGR (%)": round(cagr * 100, 4),
    "Average Monthly Return (%)": round(avg_monthly_return * 100, 4),
    "Monthly Std Dev (%)": round(monthly_std * 100, 4),
    "Annualized Volatility (%)": round(annualized_volatility * 100, 4),
    "Sharpe Ratio": round(sharpe, 4),
    "Annualized Sharpe Ratio": round(annualized_sharpe, 4),
    "Sortino Ratio": round(sortino_ratio, 4),
    "Max Drawdown (%)": round(max_drawdown * 100, 4),
    "Tracking Error (%)": round(tracking_error * 100, 4),
    "Active Return (%)": round(active_return * 100, 4),
    "Information Ratio": round(information_ratio, 4)
}

basic_df = pd.DataFrame(basic_stats.items(), columns=["Metric", "Value"])

print(basic_df)
print("\n")
print("\n")

# Wykres porównujący
plt.figure(figsize=(10, 6))
plt.plot(df.index, df["MGRN_index"], label="MGRN FIZ", linewidth=2)
plt.plot(df.index, df["REIT_index"], label="S&P Global REIT Index", linewidth=2, linestyle='--')
plt.title("Indexed Performance of MGRN FIZ vs. REIT Benchmark")
plt.xlabel("Date")
plt.ylabel("Indexed Value (Start = 100)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
print("\n")
print("\n")


# Obliczanie tracking difference
df["Tracking Difference"] = df["MGRN_ret"] - df["REIT_ret"]
df_tracking = df[["Tracking Difference"]].copy()
df_tracking["Tracking Difference"] = (df_tracking["Tracking Difference"] * 100).round(2).astype(str) + "%"
df_tracking = df_tracking.reset_index()
print(df_tracking)
print("\n")
print("\n")

import statsmodels.api as sm

# Nadwyżkowe zwroty
excess_y = df["MGRN_ret"] - rf_monthly
excess_x = df["REIT_ret"] - rf_monthly
excess_df = pd.concat([excess_x, excess_y], axis=1).dropna()
excess_df.columns = ["X", "Y"]

# Stała
X = sm.add_constant(excess_df["X"])
y = excess_df["Y"]

# Model regresji
capm_model = sm.OLS(y, X).fit()
alpha = capm_model.params["const"]
beta = capm_model.params["X"]
r_squared = capm_model.rsquared
alpha_pval = capm_model.pvalues["const"]
beta_pval = capm_model.pvalues["X"]
alpha_se = capm_model.bse["const"]
beta_se = capm_model.bse["X"]

# Tabela wyników CAPM
capm_results = pd.DataFrame({
    "Metric": ["Alpha", "Beta", "R-squared", "Alpha p-value", "Beta p-value", "Alpha SE", "Beta SE"],
    "Value": [round(alpha * 100, 4), round(beta, 4), round(r_squared, 4),
              round(alpha_pval, 4), round(beta_pval, 4),
              round(alpha_se * 100, 4), round(beta_se, 4)]
})
print(capm_results)

print("\n")
print("\n")
